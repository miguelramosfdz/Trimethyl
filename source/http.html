<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='HTTP'>/**
</span> * @class  HTTP
 * @author  Flavio De Stefano &lt;flavio.destefano@caffeinalab.com&gt;
 * HTTP network module
 */

<span id='HTTP-property-config'>/**
</span> * * **base**: The base URL of the API
 * * **timeout**: Global timeout for the requests. After this value (express in milliseconds) the requests throw an error. Default: `http://localhost`
 * * **useCache**: Check if the requests are automatically cached. Default: `true`
 * * **cacheDriver**: Cache driver to use. Default `database`
 * * **headers**: Global headers for all requests. Default: `{}`
 * * **usePingServer**: Enable the PING-Server support. Default: `true`
 * * **autoOfflineMessage**: Enable the automatic alert if the connection is offline
 * * **defaultCacheTTL**: Force a predef TTL if not found on the headers. Default: `0`
 * @type {Object}
 */
var config = _.extend({
	base: &#39;http://localhost&#39;,
	timeout: 10000,
	useCache: true,
	cacheDriver: &#39;database&#39;,
	headers: {},
	autoOfflineMessage: true,
	defaultCacheTTL: 0,
}, Alloy.CFG.T.http);
exports.config = config;


function originalErrorHandler(e) {
	var message = (e != null &amp;&amp; e.message != null) ? e.message : L(&#39;Unexpected error&#39;);
	require(&#39;T/dialog&#39;).alert(L(&#39;Error&#39;), message);
}

<span id='HTTP-property-errorHandler'>/**
</span> * @property errorHandler
 * Global error handler
 * @type {Function}
 */
exports.errorHandler = originalErrorHandler;

<span id='HTTP-method-getErrorHandler'>/**
</span> * Get the error handler
 * @param {Function} fun The new function
 */
function getErrorHandler() {
	return exports.errorHandler;
}
exports.getErrorHandler = getErrorHandler;

<span id='HTTP-method-setErrorHandler'>/**
</span> * Set a new global handler for the errors
 * @param {Function} fun The new function
 */
function setErrorHandler(fun) {
	exports.errorHandler = fun;
}
exports.setErrorHandler = setErrorHandler;

<span id='HTTP-method-resetErrorHandler'>/**
</span> * Reset the original error handler
 */
function resetErrorHandler(){
	exports.errorHandler = originalErrorHandler;
}
exports.resetErrorHandler = resetErrorHandler;


<span id='HTTP-method-isOnline'>/**
</span> * Check the internet connectivity
 * @return {Boolean} The status
 */
function isOnline() {
	return Ti.Network.online;
}
exports.isOnline = isOnline;


<span id='HTTP-property-headers'>/**
</span> * @property headers
 * Global headers
 * @type {Array}
 */
exports.headers = config.headers;

<span id='HTTP-method-addHeader'>/**
</span> * Add a global header for all requests
 * @param {String} key 		The header key
 * @param {String} value 	The header value
 */
function addHeader(key, value) {
	exports.headers[key] = value;
}
exports.addHeader = addHeader;

<span id='HTTP-method-removeHeader'>/**
</span> * Remove a global header
 * @param {String} key 		The header key
 */
function removeHeader(key) {
	delete exports.headers[key];
}
exports.removeHeader = removeHeader;

<span id='HTTP-method-resetHeaders'>/**
</span> * Reset all globals headers
 */
function resetHeaders() {
	exports.headers = {};
}
exports.resetHeaders = resetHeaders;


<span id='HTTP-property-queue'>/**
</span> * @property queue
 * Queue for HTTP Requests
 * @type {Function}
 */
exports.queue = [];

<span id='HTTP-method-isQueueEmpty'>/**
</span> * Check if the requests queue is empty
 * @return {Boolean}
 */
function isQueueEmpty(){
	return _.isEmpty(exports.queue);
}
exports.isQueueEmpty = isQueueEmpty;

<span id='HTTP-method-getQueue'>/**
</span> * Get the current requests queue
 * @return {Array}
 */
function getQueue(){
	return exports.queue;
}
exports.getQueue = getQueue;

<span id='HTTP-method-addToQueue'>/**
</span> * Add a request to queue
 * @param {HTTP.Request} request
 */
function addToQueue(request) {
	exports.queue[request.hash] = request;
}
exports.addToQueue = addToQueue;

<span id='HTTP-method-removeFromQueue'>/**
</span> * Remove a request from queue
 */
function removeFromQueue(request) {
	delete exports.queue[request.hash];
}
exports.removeFromQueue = removeFromQueue;


<span id='HTTP-property-Cache'>/**
</span> * @property Cache
 * Cache driver
 * @type {Object}
 */
exports.Cache = require(&#39;T/cache&#39;).use(config.cacheDriver);

<span id='HTTP-method-setCacheDriver'>/**
</span> * Set a different cache strategy
 * @param {String} driver
 */
function setCacheDriver(driver) {
	exports.Cache = require(&#39;T/cache&#39;).use(driver);
}
exports.setCacheDriver = setCacheDriver;


<span id='HTTP-method-resetCookies'>/**
</span> * Reset the cookies for all requests
 */
function resetCookies() {
	Ti.Network.createHTTPClient().clearCookies(config.base);
}
exports.resetCookies = resetCookies;


<span id='HTTP-method-send'>/**
</span> * The main function of the module.
 *
 * Create an HTTP.Request and resolve it
 *
 * @param  {Object}	 opt 		The request dictionary
 * * * **url**: The endpoint URL
 * * **method**: The HTTP method to use (GET|POST|PUT|PATCH|..)
 * * **headers**: An Object key-value of additional headers
 * * **timeout**: Timeout after stopping the request and triggering an error
 * * **cache**: Set to false to disable the cache
 * * **success**: The success callback
 * * **error**: The error callback
 * * **format**: Override the format for that request (like `json`)
 * * **ttl**: Override the TTL seconds for the cache
 * @return {HTTP.Request}
 */
function send(opt) {
	var Request = require(&#39;T/http/request&#39;);
	var request = new Request(opt);
	request.resolve();
	return request;
}
exports.send = send;


<span id='HTTP-method-get'>/**
</span> * @method get
 * Make a GET request to that URL
 * @param  {String}   	url The endpoint url
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error Error callback
 * @return {String}		The hash
 */
exports.get = function(url, success, error) {
	return send({
		url: url,
		method: &#39;GET&#39;,
		success: success,
		error: error
	});
};


<span id='HTTP-method-post'>/**
</span> * @method post
 * Make a POST request to that URL
 * @param  {String}   	url The endpoint url
 * @param  {Object}   	data The data
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error Error callback
 * @return {String}		The hash
 */
exports.post = function(url, data, success, error) {
	return send({
		url: url,
		method: &#39;POST&#39;,
		data: data,
		success: success,
		error: error
	});
};

<span id='HTTP-method-getJSON'>/**
</span> * @method  getJSON
 * Make a GET request to that url with that data and setting the format forced to JSON
 * @param  {String}   	url 	The endpoint url
 * @param  {Object}   	data 	The data
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error Error callback
 * @return {String}		The hash
 */
exports.getJSON = function(url, data, success, error) {
	return send({
		url: url,
		data: data,
		method: &#39;GET&#39;,
		format: &#39;json&#39;,
		success: success,
		error: error
	});
};

<span id='HTTP-method-postJSON'>/**
</span> * @method  postJSON
 * Make a POST request to that url with that data and setting the format forced to JSON
 * @param  {String}   	url 	The endpoint url
 * @param  {Object}   	data 	The data
 * @param  {Function} 	success  Success callback
 * @param  {Function} 	error Error callback
 * @return {String}		The hash
 */
exports.postJSON = function(url, data, success, error) {
	return send({
		url: url,
		data: data,
		method: &#39;POST&#39;,
		format: &#39;json&#39;,
		success: success,
		error: error
	});
};
</pre>
</body>
</html>
